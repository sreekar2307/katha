// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"github.com/sreekar2307/khata/model/table"
	mock "github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

// NewMockExpenseRepository creates a new instance of MockExpenseRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockExpenseRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockExpenseRepository {
	mock := &MockExpenseRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockExpenseRepository is an autogenerated mock type for the ExpenseRepository type
type MockExpenseRepository struct {
	mock.Mock
}

type MockExpenseRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockExpenseRepository) EXPECT() *MockExpenseRepository_Expecter {
	return &MockExpenseRepository_Expecter{mock: &_m.Mock}
}

// CreateExpense provides a mock function for the type MockExpenseRepository
func (_mock *MockExpenseRepository) CreateExpense(context1 context.Context, dB *gorm.DB, expense *table.Expense) error {
	ret := _mock.Called(context1, dB, expense)

	if len(ret) == 0 {
		panic("no return value specified for CreateExpense")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.Expense) error); ok {
		r0 = returnFunc(context1, dB, expense)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockExpenseRepository_CreateExpense_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExpense'
type MockExpenseRepository_CreateExpense_Call struct {
	*mock.Call
}

// CreateExpense is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - expense *table.Expense
func (_e *MockExpenseRepository_Expecter) CreateExpense(context1 interface{}, dB interface{}, expense interface{}) *MockExpenseRepository_CreateExpense_Call {
	return &MockExpenseRepository_CreateExpense_Call{Call: _e.mock.On("CreateExpense", context1, dB, expense)}
}

func (_c *MockExpenseRepository_CreateExpense_Call) Run(run func(context1 context.Context, dB *gorm.DB, expense *table.Expense)) *MockExpenseRepository_CreateExpense_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.Expense
		if args[2] != nil {
			arg2 = args[2].(*table.Expense)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockExpenseRepository_CreateExpense_Call) Return(err error) *MockExpenseRepository_CreateExpense_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockExpenseRepository_CreateExpense_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, expense *table.Expense) error) *MockExpenseRepository_CreateExpense_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLedgerRepository creates a new instance of MockLedgerRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLedgerRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLedgerRepository {
	mock := &MockLedgerRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLedgerRepository is an autogenerated mock type for the LedgerRepository type
type MockLedgerRepository struct {
	mock.Mock
}

type MockLedgerRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLedgerRepository) EXPECT() *MockLedgerRepository_Expecter {
	return &MockLedgerRepository_Expecter{mock: &_m.Mock}
}

// CreateLedger provides a mock function for the type MockLedgerRepository
func (_mock *MockLedgerRepository) CreateLedger(context1 context.Context, dB *gorm.DB, ledger *table.Ledger) error {
	ret := _mock.Called(context1, dB, ledger)

	if len(ret) == 0 {
		panic("no return value specified for CreateLedger")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.Ledger) error); ok {
		r0 = returnFunc(context1, dB, ledger)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLedgerRepository_CreateLedger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLedger'
type MockLedgerRepository_CreateLedger_Call struct {
	*mock.Call
}

// CreateLedger is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - ledger *table.Ledger
func (_e *MockLedgerRepository_Expecter) CreateLedger(context1 interface{}, dB interface{}, ledger interface{}) *MockLedgerRepository_CreateLedger_Call {
	return &MockLedgerRepository_CreateLedger_Call{Call: _e.mock.On("CreateLedger", context1, dB, ledger)}
}

func (_c *MockLedgerRepository_CreateLedger_Call) Run(run func(context1 context.Context, dB *gorm.DB, ledger *table.Ledger)) *MockLedgerRepository_CreateLedger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.Ledger
		if args[2] != nil {
			arg2 = args[2].(*table.Ledger)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLedgerRepository_CreateLedger_Call) Return(err error) *MockLedgerRepository_CreateLedger_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLedgerRepository_CreateLedger_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, ledger *table.Ledger) error) *MockLedgerRepository_CreateLedger_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLedgers provides a mock function for the type MockLedgerRepository
func (_mock *MockLedgerRepository) CreateLedgers(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger) error {
	ret := _mock.Called(context1, dB, ledgers)

	if len(ret) == 0 {
		panic("no return value specified for CreateLedgers")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *[]table.Ledger) error); ok {
		r0 = returnFunc(context1, dB, ledgers)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLedgerRepository_CreateLedgers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLedgers'
type MockLedgerRepository_CreateLedgers_Call struct {
	*mock.Call
}

// CreateLedgers is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - ledgers *[]table.Ledger
func (_e *MockLedgerRepository_Expecter) CreateLedgers(context1 interface{}, dB interface{}, ledgers interface{}) *MockLedgerRepository_CreateLedgers_Call {
	return &MockLedgerRepository_CreateLedgers_Call{Call: _e.mock.On("CreateLedgers", context1, dB, ledgers)}
}

func (_c *MockLedgerRepository_CreateLedgers_Call) Run(run func(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger)) *MockLedgerRepository_CreateLedgers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *[]table.Ledger
		if args[2] != nil {
			arg2 = args[2].(*[]table.Ledger)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLedgerRepository_CreateLedgers_Call) Return(err error) *MockLedgerRepository_CreateLedgers_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLedgerRepository_CreateLedgers_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger) error) *MockLedgerRepository_CreateLedgers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserInvolvedLedgers provides a mock function for the type MockLedgerRepository
func (_mock *MockLedgerRepository) GetUserInvolvedLedgers(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int) ([]table.Ledger, error) {
	ret := _mock.Called(context1, dB, v, v1, n)

	if len(ret) == 0 {
		panic("no return value specified for GetUserInvolvedLedgers")
	}

	var r0 []table.Ledger
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, uint64, uint64, int) ([]table.Ledger, error)); ok {
		return returnFunc(context1, dB, v, v1, n)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, uint64, uint64, int) []table.Ledger); ok {
		r0 = returnFunc(context1, dB, v, v1, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]table.Ledger)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, uint64, uint64, int) error); ok {
		r1 = returnFunc(context1, dB, v, v1, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLedgerRepository_GetUserInvolvedLedgers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserInvolvedLedgers'
type MockLedgerRepository_GetUserInvolvedLedgers_Call struct {
	*mock.Call
}

// GetUserInvolvedLedgers is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - v uint64
//   - v1 uint64
//   - n int
func (_e *MockLedgerRepository_Expecter) GetUserInvolvedLedgers(context1 interface{}, dB interface{}, v interface{}, v1 interface{}, n interface{}) *MockLedgerRepository_GetUserInvolvedLedgers_Call {
	return &MockLedgerRepository_GetUserInvolvedLedgers_Call{Call: _e.mock.On("GetUserInvolvedLedgers", context1, dB, v, v1, n)}
}

func (_c *MockLedgerRepository_GetUserInvolvedLedgers_Call) Run(run func(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int)) *MockLedgerRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockLedgerRepository_GetUserInvolvedLedgers_Call) Return(ledgers []table.Ledger, err error) *MockLedgerRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Return(ledgers, err)
	return _c
}

func (_c *MockLedgerRepository_GetUserInvolvedLedgers_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int) ([]table.Ledger, error)) *MockLedgerRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUserRepository creates a new instance of MockUserRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserRepository {
	mock := &MockUserRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUserRepository is an autogenerated mock type for the UserRepository type
type MockUserRepository struct {
	mock.Mock
}

type MockUserRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUserRepository) EXPECT() *MockUserRepository_Expecter {
	return &MockUserRepository_Expecter{mock: &_m.Mock}
}

// CreateUser provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) CreateUser(context1 context.Context, dB *gorm.DB, user *table.User) error {
	ret := _mock.Called(context1, dB, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.User) error); ok {
		r0 = returnFunc(context1, dB, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUserRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockUserRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - user *table.User
func (_e *MockUserRepository_Expecter) CreateUser(context1 interface{}, dB interface{}, user interface{}) *MockUserRepository_CreateUser_Call {
	return &MockUserRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", context1, dB, user)}
}

func (_c *MockUserRepository_CreateUser_Call) Run(run func(context1 context.Context, dB *gorm.DB, user *table.User)) *MockUserRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.User
		if args[2] != nil {
			arg2 = args[2].(*table.User)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserRepository_CreateUser_Call) Return(err error) *MockUserRepository_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUserRepository_CreateUser_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, user *table.User) error) *MockUserRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUserByEmail(context1 context.Context, dB *gorm.DB, s string) (table.User, error) {
	ret := _mock.Called(context1, dB, s)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 table.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, string) (table.User, error)); ok {
		return returnFunc(context1, dB, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, string) table.User); ok {
		r0 = returnFunc(context1, dB, s)
	} else {
		r0 = ret.Get(0).(table.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, string) error); ok {
		r1 = returnFunc(context1, dB, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockUserRepository_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - s string
func (_e *MockUserRepository_Expecter) GetUserByEmail(context1 interface{}, dB interface{}, s interface{}) *MockUserRepository_GetUserByEmail_Call {
	return &MockUserRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", context1, dB, s)}
}

func (_c *MockUserRepository_GetUserByEmail_Call) Run(run func(context1 context.Context, dB *gorm.DB, s string)) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetUserByEmail_Call) Return(user table.User, err error) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockUserRepository_GetUserByEmail_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, s string) (table.User, error)) *MockUserRepository_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByIDs provides a mock function for the type MockUserRepository
func (_mock *MockUserRepository) GetUsersByIDs(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool) ([]table.User, error) {
	ret := _mock.Called(context1, dB, uint64ToBool)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByIDs")
	}

	var r0 []table.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, map[uint64]bool) ([]table.User, error)); ok {
		return returnFunc(context1, dB, uint64ToBool)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, map[uint64]bool) []table.User); ok {
		r0 = returnFunc(context1, dB, uint64ToBool)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]table.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, map[uint64]bool) error); ok {
		r1 = returnFunc(context1, dB, uint64ToBool)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockUserRepository_GetUsersByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByIDs'
type MockUserRepository_GetUsersByIDs_Call struct {
	*mock.Call
}

// GetUsersByIDs is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - uint64ToBool map[uint64]bool
func (_e *MockUserRepository_Expecter) GetUsersByIDs(context1 interface{}, dB interface{}, uint64ToBool interface{}) *MockUserRepository_GetUsersByIDs_Call {
	return &MockUserRepository_GetUsersByIDs_Call{Call: _e.mock.On("GetUsersByIDs", context1, dB, uint64ToBool)}
}

func (_c *MockUserRepository_GetUsersByIDs_Call) Run(run func(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool)) *MockUserRepository_GetUsersByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 map[uint64]bool
		if args[2] != nil {
			arg2 = args[2].(map[uint64]bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockUserRepository_GetUsersByIDs_Call) Return(users []table.User, err error) *MockUserRepository_GetUsersByIDs_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockUserRepository_GetUsersByIDs_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool) ([]table.User, error)) *MockUserRepository_GetUsersByIDs_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// CreateExpense provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateExpense(context1 context.Context, dB *gorm.DB, expense *table.Expense) error {
	ret := _mock.Called(context1, dB, expense)

	if len(ret) == 0 {
		panic("no return value specified for CreateExpense")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.Expense) error); ok {
		r0 = returnFunc(context1, dB, expense)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateExpense_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateExpense'
type MockRepository_CreateExpense_Call struct {
	*mock.Call
}

// CreateExpense is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - expense *table.Expense
func (_e *MockRepository_Expecter) CreateExpense(context1 interface{}, dB interface{}, expense interface{}) *MockRepository_CreateExpense_Call {
	return &MockRepository_CreateExpense_Call{Call: _e.mock.On("CreateExpense", context1, dB, expense)}
}

func (_c *MockRepository_CreateExpense_Call) Run(run func(context1 context.Context, dB *gorm.DB, expense *table.Expense)) *MockRepository_CreateExpense_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.Expense
		if args[2] != nil {
			arg2 = args[2].(*table.Expense)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_CreateExpense_Call) Return(err error) *MockRepository_CreateExpense_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateExpense_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, expense *table.Expense) error) *MockRepository_CreateExpense_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLedger provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateLedger(context1 context.Context, dB *gorm.DB, ledger *table.Ledger) error {
	ret := _mock.Called(context1, dB, ledger)

	if len(ret) == 0 {
		panic("no return value specified for CreateLedger")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.Ledger) error); ok {
		r0 = returnFunc(context1, dB, ledger)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateLedger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLedger'
type MockRepository_CreateLedger_Call struct {
	*mock.Call
}

// CreateLedger is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - ledger *table.Ledger
func (_e *MockRepository_Expecter) CreateLedger(context1 interface{}, dB interface{}, ledger interface{}) *MockRepository_CreateLedger_Call {
	return &MockRepository_CreateLedger_Call{Call: _e.mock.On("CreateLedger", context1, dB, ledger)}
}

func (_c *MockRepository_CreateLedger_Call) Run(run func(context1 context.Context, dB *gorm.DB, ledger *table.Ledger)) *MockRepository_CreateLedger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.Ledger
		if args[2] != nil {
			arg2 = args[2].(*table.Ledger)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_CreateLedger_Call) Return(err error) *MockRepository_CreateLedger_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateLedger_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, ledger *table.Ledger) error) *MockRepository_CreateLedger_Call {
	_c.Call.Return(run)
	return _c
}

// CreateLedgers provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateLedgers(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger) error {
	ret := _mock.Called(context1, dB, ledgers)

	if len(ret) == 0 {
		panic("no return value specified for CreateLedgers")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *[]table.Ledger) error); ok {
		r0 = returnFunc(context1, dB, ledgers)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateLedgers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateLedgers'
type MockRepository_CreateLedgers_Call struct {
	*mock.Call
}

// CreateLedgers is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - ledgers *[]table.Ledger
func (_e *MockRepository_Expecter) CreateLedgers(context1 interface{}, dB interface{}, ledgers interface{}) *MockRepository_CreateLedgers_Call {
	return &MockRepository_CreateLedgers_Call{Call: _e.mock.On("CreateLedgers", context1, dB, ledgers)}
}

func (_c *MockRepository_CreateLedgers_Call) Run(run func(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger)) *MockRepository_CreateLedgers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *[]table.Ledger
		if args[2] != nil {
			arg2 = args[2].(*[]table.Ledger)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_CreateLedgers_Call) Return(err error) *MockRepository_CreateLedgers_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateLedgers_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, ledgers *[]table.Ledger) error) *MockRepository_CreateLedgers_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUser provides a mock function for the type MockRepository
func (_mock *MockRepository) CreateUser(context1 context.Context, dB *gorm.DB, user *table.User) error {
	ret := _mock.Called(context1, dB, user)

	if len(ret) == 0 {
		panic("no return value specified for CreateUser")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, *table.User) error); ok {
		r0 = returnFunc(context1, dB, user)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockRepository_CreateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUser'
type MockRepository_CreateUser_Call struct {
	*mock.Call
}

// CreateUser is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - user *table.User
func (_e *MockRepository_Expecter) CreateUser(context1 interface{}, dB interface{}, user interface{}) *MockRepository_CreateUser_Call {
	return &MockRepository_CreateUser_Call{Call: _e.mock.On("CreateUser", context1, dB, user)}
}

func (_c *MockRepository_CreateUser_Call) Run(run func(context1 context.Context, dB *gorm.DB, user *table.User)) *MockRepository_CreateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 *table.User
		if args[2] != nil {
			arg2 = args[2].(*table.User)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_CreateUser_Call) Return(err error) *MockRepository_CreateUser_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockRepository_CreateUser_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, user *table.User) error) *MockRepository_CreateUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByEmail provides a mock function for the type MockRepository
func (_mock *MockRepository) GetUserByEmail(context1 context.Context, dB *gorm.DB, s string) (table.User, error) {
	ret := _mock.Called(context1, dB, s)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByEmail")
	}

	var r0 table.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, string) (table.User, error)); ok {
		return returnFunc(context1, dB, s)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, string) table.User); ok {
		r0 = returnFunc(context1, dB, s)
	} else {
		r0 = ret.Get(0).(table.User)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, string) error); ok {
		r1 = returnFunc(context1, dB, s)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetUserByEmail_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByEmail'
type MockRepository_GetUserByEmail_Call struct {
	*mock.Call
}

// GetUserByEmail is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - s string
func (_e *MockRepository_Expecter) GetUserByEmail(context1 interface{}, dB interface{}, s interface{}) *MockRepository_GetUserByEmail_Call {
	return &MockRepository_GetUserByEmail_Call{Call: _e.mock.On("GetUserByEmail", context1, dB, s)}
}

func (_c *MockRepository_GetUserByEmail_Call) Run(run func(context1 context.Context, dB *gorm.DB, s string)) *MockRepository_GetUserByEmail_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetUserByEmail_Call) Return(user table.User, err error) *MockRepository_GetUserByEmail_Call {
	_c.Call.Return(user, err)
	return _c
}

func (_c *MockRepository_GetUserByEmail_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, s string) (table.User, error)) *MockRepository_GetUserByEmail_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserInvolvedLedgers provides a mock function for the type MockRepository
func (_mock *MockRepository) GetUserInvolvedLedgers(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int) ([]table.Ledger, error) {
	ret := _mock.Called(context1, dB, v, v1, n)

	if len(ret) == 0 {
		panic("no return value specified for GetUserInvolvedLedgers")
	}

	var r0 []table.Ledger
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, uint64, uint64, int) ([]table.Ledger, error)); ok {
		return returnFunc(context1, dB, v, v1, n)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, uint64, uint64, int) []table.Ledger); ok {
		r0 = returnFunc(context1, dB, v, v1, n)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]table.Ledger)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, uint64, uint64, int) error); ok {
		r1 = returnFunc(context1, dB, v, v1, n)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetUserInvolvedLedgers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserInvolvedLedgers'
type MockRepository_GetUserInvolvedLedgers_Call struct {
	*mock.Call
}

// GetUserInvolvedLedgers is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - v uint64
//   - v1 uint64
//   - n int
func (_e *MockRepository_Expecter) GetUserInvolvedLedgers(context1 interface{}, dB interface{}, v interface{}, v1 interface{}, n interface{}) *MockRepository_GetUserInvolvedLedgers_Call {
	return &MockRepository_GetUserInvolvedLedgers_Call{Call: _e.mock.On("GetUserInvolvedLedgers", context1, dB, v, v1, n)}
}

func (_c *MockRepository_GetUserInvolvedLedgers_Call) Run(run func(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int)) *MockRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 uint64
		if args[2] != nil {
			arg2 = args[2].(uint64)
		}
		var arg3 uint64
		if args[3] != nil {
			arg3 = args[3].(uint64)
		}
		var arg4 int
		if args[4] != nil {
			arg4 = args[4].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockRepository_GetUserInvolvedLedgers_Call) Return(ledgers []table.Ledger, err error) *MockRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Return(ledgers, err)
	return _c
}

func (_c *MockRepository_GetUserInvolvedLedgers_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, v uint64, v1 uint64, n int) ([]table.Ledger, error)) *MockRepository_GetUserInvolvedLedgers_Call {
	_c.Call.Return(run)
	return _c
}

// GetUsersByIDs provides a mock function for the type MockRepository
func (_mock *MockRepository) GetUsersByIDs(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool) ([]table.User, error) {
	ret := _mock.Called(context1, dB, uint64ToBool)

	if len(ret) == 0 {
		panic("no return value specified for GetUsersByIDs")
	}

	var r0 []table.User
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, map[uint64]bool) ([]table.User, error)); ok {
		return returnFunc(context1, dB, uint64ToBool)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, *gorm.DB, map[uint64]bool) []table.User); ok {
		r0 = returnFunc(context1, dB, uint64ToBool)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]table.User)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, *gorm.DB, map[uint64]bool) error); ok {
		r1 = returnFunc(context1, dB, uint64ToBool)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockRepository_GetUsersByIDs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUsersByIDs'
type MockRepository_GetUsersByIDs_Call struct {
	*mock.Call
}

// GetUsersByIDs is a helper method to define mock.On call
//   - context1 context.Context
//   - dB *gorm.DB
//   - uint64ToBool map[uint64]bool
func (_e *MockRepository_Expecter) GetUsersByIDs(context1 interface{}, dB interface{}, uint64ToBool interface{}) *MockRepository_GetUsersByIDs_Call {
	return &MockRepository_GetUsersByIDs_Call{Call: _e.mock.On("GetUsersByIDs", context1, dB, uint64ToBool)}
}

func (_c *MockRepository_GetUsersByIDs_Call) Run(run func(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool)) *MockRepository_GetUsersByIDs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		var arg2 map[uint64]bool
		if args[2] != nil {
			arg2 = args[2].(map[uint64]bool)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockRepository_GetUsersByIDs_Call) Return(users []table.User, err error) *MockRepository_GetUsersByIDs_Call {
	_c.Call.Return(users, err)
	return _c
}

func (_c *MockRepository_GetUsersByIDs_Call) RunAndReturn(run func(context1 context.Context, dB *gorm.DB, uint64ToBool map[uint64]bool) ([]table.User, error)) *MockRepository_GetUsersByIDs_Call {
	_c.Call.Return(run)
	return _c
}
